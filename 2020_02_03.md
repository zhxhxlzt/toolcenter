## 工作内容

* C++练习

  > 通过读取头文件来获取类的继承关系，用于组件模式中获取特定类型的组件
  >
  > ***
  >
  > **定义元数据结构体及相关宏：**
  >
  > ```cpp
  > #define STD std::
  > struct MetaObject
  > {
  > 	const STD string className;
  > 	const STD string baseClassName;
  > 	const int classID;
  > 	const int baseClassID;
  > 	const MetaObject* baseMetaObject();
  > 	bool inherits(const MetaObject* metaObject);
  > 	static STD map<STD string, MetaObject*> metaObjects;
  > 	static MetaObject* getMetaObject(STD string className);
  > };
  > 
  > #define META_OBJECT		\
  > public:		\
  > 	static MetaObject metaObject;	\
  > 	virtual MetaObject* getMetaObject() { return &metaObject; }	\
  > 	virtual STD string className(){ return metaObject.className;}	\
  > 	virtual STD string baseClassName() {return metaObject.baseClassName; }	\
  > 	virtual int classID() { return metaObject.classID; }	\
  > 	virtual int baseClassID() { return metaObject.baseClassID; }
  > ```
  >
  > ***
  >
  > **在类定义中加入META_OBJECT宏，如：**
  >
  > ```c++
  > //Object.h头文件
  > class Object
  > {
  > 	META_OBJECT
  > };
  > 
  > //GameObject.h头文件
  > class GameObject : public Object
  > {
  > 	META_OBJECT
  > };
  > ```
  >
  > ***
  >
  > **编写处理头文件的python工具：**
  >
  > 用于识别类名及继承关系的正则表达式:
  >
  > ```python
  > class_pattern = re.compile("class (?P<className>\w+) *:? *(public (?P<parentName>\w+))?.*{.*META_OBJECT.*}", re.M | re.S)
  > ```
  >
  > 生成初始化类的静态数据的文件
  >
  > ```c++
  > #include "Object.h"
  > MetaObject Object::metaObject = MetaObject{ "Object", "", 5, -1};
  > ```
  >
  > ```c++
  > #include "GameObject.h"
  > MetaObject GameObject::metaObject = MetaObject{ "GameObject", "Object", 4, -1};
  > ```
  >
  > ***
  >
  > **生成类名到元数据的字典映射：**
  >
  > ```c++
  > map<string, MetaObject*> MetaObject::metaObjects = {
  > 	pair<string, MetaObject*>("GameObject", &GameObject::metaObject),
  > 	pair<string, MetaObject*>("Object", &Object::metaObject),
  > };
  > ```
  >
  > ***
  >
  > **定时器实现**
  >
  > 参考qt定时器接口
  >
  > 使用有序set来管理timer，当最近的定时器结束时间大于当前时间时，sleep程序
  >
  > ```c++
  > //Application.h
  > void Application::exec()
  > {
  > 	while (!m_shutdown)
  > 	{
  > 		auto targetTimePoint = TimerMgr::instance().nextTimerCallTimePoint();
  > 		if (system_clock::now() < targetTimePoint)
  > 		{
  > 			auto ms = duration_cast<milliseconds>(targetTimePoint - system_clock::now()).count();
  > 			Sleep(ms);
  > 		}	
  > 		TimerMgr::instance().schedule();
  > 	}
  > }
  > ```
  >
  > ```c++
  > void TimerMgr::schedule()
  > {
  > 	auto it = m_activeTimers.begin();
  > 	while (it != m_activeTimers.end())
  > 	{
  > 		auto timer = *it;
  > 		if (timer->getExpireTime() <= system_clock::now())
  > 		{
  > 			m_activeTimers.erase(timer);
  > 			timer->call();
  > 			it = m_activeTimers.begin();	// 设置it为最近时间的timer
  > 		}
  > 		else
  > 		{	// 后续timer的expire时间都大于当前时间
  > 			break;
  > 		}
  > 	}
  > }
  > ```
  >
  > ```c++
  > //定时器使用示例
  > void run()
  > {
  > 	cout << "runing" << endl;
  > }
  > 
  > int main()
  > {
  > 	Application app;
  > 	auto t = make_shared<Timer>();
  > 	t->timeOut += run;
  > 	t->start(1000);
  > 	app.exec();
  > 	return 0;
  > }
  > ```
  >
  > ***
  >
  > 委托实现**
  >
  > 使用变参模板和functional函数库
  >
  > ```c++
  > #pragma once
  > 
  > #include "Object.h"
  > #include <iterator>
  > namespace yk
  > {
  > 	template<typename... ArgsType>
  > 	class Delegate : public Object
  > 	{
  > 	public:
  > 		Delegate(Delegate<ArgsType...>&) = delete;
  > 		Delegate(Delegate<ArgsType...>&&) = delete;
  > 		Delegate() = default;
  > 		using FnType = void(*)(ArgsType...);
  > 		void operator +=(STD function<void(ArgsType...)> observer)
  > 		{
  > 			m_observers.push_back(observer);
  > 		}
  > 		void operator +=(Delegate<ArgsType...>& delegate)
  > 		{
  > 			m_delegates.push_back(&delegate);
  > 		}
  > 
  > 		void operator -=(STD function<void(ArgsType...)> observer)
  > 		{
  > 			size_t tarAddr = getFunctionAddr(observer);
  > 			auto it = STD remove_if(m_observers.begin(), m_observers.end(),
  > 				[=](auto& ob)
  > 				{
  > 					auto addr = *(size_t*)ob.target<FnType>();
  > 					return addr == tarAddr;
  > 				});
  > 			m_observers.erase(it, m_observers.end());
  > 		}
  > 
  > 		void operator -=(Delegate<ArgsType...>& delegate)
  > 		{
  > 			auto dele_ptr = &delegate;
  > 			auto it = STD remove_if(m_delegates.begin(), m_delegates.end(), [=](Delegate* dele)
  > 				{
  > 					return dele == dele_ptr;
  > 				});
  > 			m_delegates.erase(it, m_delegates.end());
  > 		}
  > 
  > 		void operator()(ArgsType... args)
  > 		{
  > 			STD for_each(
  > 				m_observers.begin(), m_observers.end(),
  > 				[=](auto& ob) { ob(args...); });
  > 
  > 			STD for_each(
  > 				m_delegates.begin(), m_delegates.end(), [=](Delegate* dele)
  > 				{
  > 					(*dele)(args...);
  > 				});
  > 		}
  > 
  > 	private:
  > 		size_t getFunctionAddr(STD function<void(ArgsType...)>& func)
  > 		{
  > 			return *(size_t*)func.target<FnType>();
  > 		}
  > 		STD vector<STD function<void(ArgsType...)>> m_observers;
  > 		STD vector<Delegate*> m_delegates;
  > 	};
  > }
  > ```
  >
  > **使用示例**
  >
  > ```c++
  > void run(int a)
  > {
  > 	cout << "run" << a << endl;
  > }
  > 
  > void say(string name)
  > {
  > 	cout << "my name is: " << name << endl;
  > }
  > int main()
  > {
  > 	Delegate<int> dele;
  > 	dele += run;
  > 	dele(20);
  > 	dele -= run;
  > 
  > 	Delegate<string> dele2;
  > 	dele2 += say;
  > 	dele2("lyq");
  > 	dele2 -= say;
  > 	getchar();
  > 	return 0;
  > }
  > ```
  >
  > 
  >
  > 

