## 工作内容

* C++练习

  > 通过读取头文件来获取类的继承关系，用于组件模式中获取特定类型的组件
  >
  > ***
  >
  > **定义元数据结构体及相关宏：**
  >
  > ```cpp
  > #define STD std::
  > struct MetaObject
  > {
  > 	const STD string className;
  > 	const STD string baseClassName;
  > 	const int classID;
  > 	const int baseClassID;
  > 	const MetaObject* baseMetaObject();
  > 	bool inherits(const MetaObject* metaObject);
  > 	static STD map<STD string, MetaObject*> metaObjects;
  > 	static MetaObject* getMetaObject(STD string className);
  > };
  > 
  > #define META_OBJECT		\
  > public:		\
  > 	static MetaObject metaObject;	\
  > 	virtual MetaObject* getMetaObject() { return &metaObject; }	\
  > 	virtual STD string className(){ return metaObject.className;}	\
  > 	virtual STD string baseClassName() {return metaObject.baseClassName; }	\
  > 	virtual int classID() { return metaObject.classID; }	\
  > 	virtual int baseClassID() { return metaObject.baseClassID; }
  > ```
  >
  > ***
  >
  > **在类定义中加入META_OBJECT宏，如：**
  >
  > ```c++
  > //Object.h头文件
  > class Object
  > {
  > 	META_OBJECT
  > };
  > 
  > //GameObject.h头文件
  > class GameObject : public Object
  > {
  > 	META_OBJECT
  > };
  > ```
  >
  > ***
  >
  > **编写处理头文件的python工具：**
  >
  > 用于识别类名及继承关系的正则表达式:
  >
  > ```python
  > class_pattern = re.compile("class (?P<className>\w+) *:? *(public (?P<parentName>\w+))?.*{.*META_OBJECT.*}", re.M | re.S)
  > ```
  >
  > 生成初始化类的静态数据的文件
  >
  > ```c++
  > #include "Object.h"
  > MetaObject Object::metaObject = MetaObject{ "Object", "", 5, -1};
  > ```
  >
  > ```c++
  > #include "GameObject.h"
  > MetaObject GameObject::metaObject = MetaObject{ "GameObject", "Object", 4, -1};
  > ```
  >
  > ***
  >
  > **生成类名到元数据的字典映射：**
  >
  > ```c++
  > map<string, MetaObject*> MetaObject::metaObjects = {
  > 	pair<string, MetaObject*>("GameObject", &GameObject::metaObject),
  > 	pair<string, MetaObject*>("Object", &Object::metaObject),
  > };
  > ```
  >
  > ***
  >
  > **定时器实现**
  >
  > 参考qt定时器接口
  >
  > 使用有序set来管理timer，当最近的定时器结束时间大于当前时间时，sleep程序
  >
  > ```c++
  > //Application.h
  > void Application::exec()
  > {
  > 	while (!m_shutdown)
  > 	{
  > 		auto targetTimePoint = TimerMgr::instance().nextTimerCallTimePoint();
  > 		if (system_clock::now() < targetTimePoint)
  > 		{
  > 			auto ms = duration_cast<milliseconds>(targetTimePoint - system_clock::now()).count();
  > 			Sleep(ms);
  > 		}	
  > 		TimerMgr::instance().schedule();
  > 	}
  > }
  > ```
  >
  > ```c++
  > void TimerMgr::schedule()
  > {
  > 	auto it = m_activeTimers.begin();
  > 	while (it != m_activeTimers.end())
  > 	{
  > 		auto timer = *it;
  > 		if (timer->getExpireTime() <= system_clock::now())
  > 		{
  > 			m_activeTimers.erase(timer);
  > 			timer->call();
  > 			it = m_activeTimers.begin();	// 设置it为最近时间的timer
  > 		}
  > 		else
  > 		{	// 后续timer的expire时间都大于当前时间
  > 			break;
  > 		}
  > 	}
  > }
  > ```
  >
  > ```c++
  > //定时器使用示例
  > void run()
  > {
  > 	cout << "runing" << endl;
  > }
  > 
  > int main()
  > {
  > 	Application app;
  > 	auto t = make_shared<Timer>();
  > 	t->timeOut += run;
  > 	t->start(1000);
  > 	app.exec();
  > 	return 0;
  > }
  > ```
  >
  > 
  >
  > 

